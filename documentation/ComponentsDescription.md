## Документация по Компонентам Системы CDC Bridge

### 1. Слой Конфигурации (`CdcBridge.Configuration`)

Этот слой отвечает за чтение, валидацию и предоставление доступа к конфигурации всей системы.

#### Компонент: `CdcConfigurationContext`

*   **Назначение:** Является центральной точкой доступа ко всей конфигурации системы в runtime. Предоставляет удобные и быстрые методы для получения настроек и связей между ними.

*   **Ключевые Обязанности:**
    *   Хранит десериализованный объект `CdcSettings`.
    *   Предоставляет методы для быстрого поиска компонентов по имени (`GetConnection`, `GetReceiver` и т.д.).
    *   Предоставляет методы для получения связанных сущностей (например, `GetReceiversForTrackingInstance`).
    *   Формирует полный конвейер обработки (`ReceiverPipeline`) для конкретного получателя.

*   **Принцип Работы:**
    *   При создании `CdcConfigurationContext` получает готовый объект `CdcSettings`.
    *   Для ускорения доступа он немедленно преобразует списки компонентов в словари (`Dictionary`) и `ILookup` коллекции. Это позволяет получать компоненты за время O(1) вместо O(n).
    *   Вся конфигурация является иммутабельной на время жизни приложения.

*   **Взаимодействие:**
    *   **Используется:** `CdcBridgeOrchestrator` (для получения списка воркеров), `SourceWorker` (для получения своей конфигурации), `ReceiverWorker` (для получения своего конвейера).

#### Компонент: `CdcConfigurationContextBuilder`

*   **Назначение:** Fluent-строитель, отвечающий за пошаговое создание `CdcConfigurationContext` из различных источников.

*   **Ключевые Обязанности:**
    *   Чтение YAML-конфигурации из файла или строки.
    *   Предварительная обработка YAML с помощью `YamlProcessor` для подстановки значений из `IConfiguration` и содержимого файлов.
    *   Десериализация обработанного YAML в объект `CdcSettings`.
    *   Валидация объекта `CdcSettings` с помощью `FluentValidation` для проверки синтаксиса и логических связей.
    *   Создание и возврат готового экземпляра `CdcConfigurationContext`.

*   **Взаимодействие:**
    *   **Используется:** В `Program.cs` при настройке DI для создания синглтона `ICdcConfigurationContext`.

### 2. Слой Хранения Состояния (`CdcBridge.Persistence`)

Этот слой обеспечивает надежность системы, предоставляя персистентный буфер для событий изменений и отслеживая прогресс обработки.

#### Компонент: `ICdcBridgeStorage` (Реализация: `EfCoreSqliteStorage`)

*   **Назначение:** Абстракция над базой данных состояния. Гарантирует, что ни одно изменение не будет потеряно при перезапуске или сбое сервиса.

*   **Ключевые Обязанности:**
    *   **Буферизация:** Сохранение `TrackedChange` событий, полученных от `SourceWorker`, в базу данных (SQLite).
    *   **Отслеживание состояния источника:** Хранение последней обработанной метки строки (`LastProcessedRowLabel`) для каждого `TrackingInstance`.
    *   **Отслеживание состояния получателей:** Для каждого события в буфере хранит независимый статус доставки (`Pending`, `Success`, `Failed`) для каждого получателя.
    *   **Предоставление работы:** Предоставляет `ReceiverWorker`-ам списки ожидающих (`Pending`) событий.
    *   **Очистка:** Удаление старых, полностью обработанных событий.

*   **Принцип Работы:**
    *   Использует EF Core и SQLite для хранения данных в локальном файле.
    *   **Запись:** `SourceWorker` вызывает `AddChangesToBufferAsync`. Метод создает `BufferedChangeEvent` и для него N записей `ReceiverDeliveryStatus` (по одной на каждого получателя, связанного с этим `TrackingInstance`), все со статусом `Pending`.
    *   **Чтение:** `ReceiverWorker` вызывает `GetPendingChangesAsync`, передавая свое имя. EF Core выполняет запрос, находя события, у которых статус для данного получателя равен `Pending`.
    *   **Обновление:** После попытки отправки `ReceiverWorker` вызывает `UpdateChangeStatusAsync`, изменяя статус на `Success` или `Failed`.

*   **Взаимодействие:**
    *   **Используется:** `SourceWorker` (запись), `ReceiverWorker` (чтение и обновление), `CleanupWorker` (удаление).

### 3. Ядро Системы (`CdcBridge.Service`)

Это "двигатель" приложения, содержащий логику управления и выполнения фоновых задач.

#### Компонент: `CdcBridgeOrchestrator`

*   **Назначение:** Главный управляющий сервис. Запускается один раз при старте приложения и "дирижирует" всеми остальными задачами.

*   **Ключевые Обязанности:**
    *   При старте (`StartAsync`) читает `ICdcConfigurationContext`.
    *   **Инициализирует источники:** Для каждого активного `TrackingInstance` вызывает `ICdcSource.EnableTrackingInstance`, чтобы гарантировать, что CDC включен в базе данных.
    *   **Запускает воркеры:** Создает и запускает по одной долгоживущей задаче (`Task`) для каждого `SourceWorker` и `ReceiverWorker`.
    *   При остановке (`StopAsync`) корректно сигнализирует всем запущенным задачам о необходимости завершения через `CancellationToken`.

*   **Взаимодействие:**
    *   **Использует:** `ICdcConfigurationContext`, `ComponentFactory`, `IServiceProvider`.
    *   **Создает и управляет:** `SourceWorker`, `ReceiverWorker`.

#### Компонент: `SourceWorker`

*   **Назначение:** Отвечает за опрос **одного** источника данных (`TrackingInstance`) и помещение изменений в буфер.

*   **Принцип Работы (Цикл):**
    1.  Вызвать `_storage.GetLastProcessedRowLabelAsync()` для получения "курсора".
    2.  Вызвать `_cdcSource.GetChanges()` с этим курсором для получения новых изменений.
    3.  Если изменения есть:
        *   Вызвать `_storage.AddChangesToBufferAsync()` для их сохранения.
        *   Вызвать `_storage.SaveLastProcessedRowLabelAsync()` для обновления "курсора".
    4.  Ждать интервал, указанный в `checkIntervalInSeconds`.
    5.  Повторить.

*   **Взаимодействие:**
    *   **Использует:** `ICdcSource`, `ICdcBridgeStorage`.

#### Компонент: `ReceiverWorker`

*   **Назначение:** Отвечает за доставку событий **одному** получателю (`Receiver`).

*   **Принцип Работы (Цикл):**
    1.  Вызвать `_storage.GetPendingChangesAsync()`, передав свое имя, чтобы получить пачку работы.
    2.  Для каждого полученного `BufferedChangeEvent`:
        *   **Фильтрация:** Если в конфигурации указан фильтр, применить `IFilter.IsMatch()`. Если `false` — пометить как успешно обработанное и пропустить.
        *   **Трансформация:** Если указан трансформер, применить `ITransformer.Transform()` и сохранить результат.
        *   **Отправка:** Вызвать `IReceiver.SendAsync()`, передав финальные данные.
        *   **Обновление статуса:** Вызвать `_storage.UpdateChangeStatusAsync()` с результатом отправки (`Success` или `Failed`).
    3.  Ждать фиксированный интервал.
    4.  Повторить.

*   **Взаимодействие:**
    *   **Использует:** `ICdcBridgeStorage`, `IFilter`, `ITransformer`, `IReceiver` (все через `ComponentFactory`).

### 4. Компоненты-Реализации (`CdcBridge.Application`)

Это "инструменты", выполняющие конкретную работу.

#### Компонент: `SqlServerCdcSource`

*   **Назначение:** Реализация `ICdcSource` для работы с Microsoft SQL Server Change Data Capture.
*   **Принцип Работы:**
    *   `EnableTrackingInstance`: Проверяет, включен ли CDC на базе и таблице, и при необходимости выполняет системные процедуры `sys.sp_cdc_enable_db` и `sys.sp_cdc_enable_table`. Метод идемпотентен.
    *   `GetChanges`: Использует библиотеку `MsSqlCdc` для вызова системных функций `cdc.fn_cdc_get_all_changes_*` с передачей диапазона LSN (Log Sequence Number).

#### Компонент: `JsonPathFilter`

*   **Назначение:** Реализация `IFilter` для фильтрации на основе JsonPath-выражений.
*   **Принцип Работы:**
    *   `IsMatch`: Сериализует входящий объект `TrackedChange` в JSON.
    *   Использует библиотеку `Newtonsoft.Json` для выполнения JsonPath-выражения (из параметра `expression`) над этим JSON.
    *   Возвращает `true`, если выражение нашло хотя бы один результат, иначе `false`.

#### Компонент: `JSONataTransformer`

*   **Назначение:** Реализация `ITransformer` для преобразования данных с помощью языка JSONata.
*   **Принцип Работы:**
    *   `Transform`: Сериализует входящий `TrackedChange` в JSON.
    *   Использует библиотеку `Jsonata.Net.Native` для выполнения JSONata-выражения (из параметра `transformation`) над этим JSON.
    *   Возвращает результат трансформации в виде `JsonElement`. Этот результат затем помещается в поле `TrackedChange.Data.TransformedData`.

#### Компонент: `WebhookReceiver`

*   **Назначение:** Реализация `IReceiver` для отправки данных на HTTP/S эндпоинт.
*   **Принцип Работы:**
    *   `SendAsync`: Использует `HttpClient` (предоставляемый через DI) для отправки HTTP-запроса.
    *   **Выбор тела запроса:** Если у `TrackedChange.Data.TransformedData` есть значение, в тело запроса будет сериализован именно он. В противном случае будет сериализован весь объект `TrackedChange`.
    *   Поддерживает настройку URL, HTTP-метода и заголовков из параметров в YAML.
    *   Поддерживает Handlebars-шаблоны в URL для создания динамических эндпоинтов.